### 动态规划

英文：(Dynamic Programming, DP)

------

#### 1. 基本思想

`是一种在数学、计算机科学和经济学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划算法是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。` 

**其核心是：将一个问题分解为若干个子问题**

#### 2. 内涵

1. 动态规划（Dynamic Programming）对于子问题重叠的情况特别有效，因为它将子问题的解保存在表格中，当需要某个子问题的解时，直接取值即可，从而避免重复计算！

2. 动态规划是一种灵活的方法，不存在一种万能的动态规划算法可以解决各类最优化问题（每种算法都有它的缺陷）。所以除了要对基本概念和方法正确理解外，必须具体问题具体分析处理，用灵活的方法建立数学模型，用创造性的技巧去求解。

   

#### 3. 适用问题

1. 最优化原理：最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构
2. 无后项性：每个状态都是过去历史的一个完整总结（某状态以后的过程不会影响以前的状态）
3. 子问题重叠问题：我们必须保证我们分割成的子问题也能按照相同的方法分割成更小的自问题， 并这些自问题的最终分割情况是可以解决的。

#### 4. 案例

##### 4.1 爬楼梯问题

**问题描述**：有一个楼梯总共n个台阶，只能往上走，每次只能上1个、2个台阶，总共有多少种走法。

**问题分析**：假如只差一步就能走完整个楼梯，要分为几种情况？因为每一步能走一级或者两级台阶，所以有如下两种情况：`1.最后一步走2级台阶` `2.最后一步走1级台阶` 。斐波切纳数列

公式：`F(n) = F(n-1)+F(n-2) n>2 ; F(n) = n n<=2;`

**样例代码**：

```python
#斐波切纳问题
def dp(n):# n为阶梯数
    if n <= 2: return n
    else:return dp(n-2)+dp(n-1)    
```



##### 4.2 背包问题

**问题描述**：有n个物品，它们有各自的重量和价值，现有给定承重的背包，如何让背包里装入的物品具有最大的价值总和

**测试样例** ：TW=10,N=5,W={2,2,6,5,4},V={6,3,5,4,6}

**样例分析**：

| name | weight | value |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |  10  |
| :--: | :----: | :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  a   |   2    |   6   |  0   |  6   |  6   |  6   |  6   |  6   |  6   |  6   |  6   |  6   |
|  b   |   2    |   3   |  0   |  6   |  6   |  9   |  9   |  9   |  9   |  9   |  9   |  9   |
|  c   |   6    |   5   |  0   |  6   |  6   |  9   |  9   |  9   |  9   |  11  |  11  |  14  |
|  d   |   5    |   4   |  0   |  6   |  6   |  9   |  9   |  9   |  10  |  11  |  13  |  14  |
|  e   |   4    |   6   |  0   |  6   |  6   |  9   |  9   |  12  |  12  |  15  |  15  |  15  |

将问题理解为：承重从1到10最多能够获得最大价值，原则是承重大的一定比承重小的价值只多不少。递推策略：为了使得背包中物品总价值的最大化，第i件物品是否放入背包中？

例如：`a1=0`代表：承重为1且只有a一件时的最大价值；`c3` 代表承重为3且有a,b,c三件时的最大价值；等等一次类推。令total_value[i,j] 表示承重为j 且有name[0],name[1]...name[i] (i+1)件时的最大价值

递推计算式：total_value[i,j] = max{total_value[i-1,j],total_value[i-1,j-w_i]+vi}

其中：total_value[i-1,j]：考虑的是不往背包中加入下个物件i 的最大价值；

另外就是考虑往背包中添加i【一定有i】时的最大价值,此时的最大价值由两部分构成：`i的价值pi`+当前承重减去i的重量`wi` 所得剩余承重量所能承载的最大价值【不包括物件i】total_value[i-1,j-w_i]

**样例代码**：

```python
def packages (capacity,N,W,V):
    table_value = np.zeros((N,capacity))   
    #初始化第一行
    for i in range(capacity):
        if W[0]<=i+1:
            table_value[0][i] = V[0]  
    #计算其他行
    for j in range(1,N):
        for i in range(capacity):
            if i+1 < W[j]:
                table_value[j,i] = table_value[j-1,i]
            else:
                index = 0 if i+1 == W[j] else i-W[j]
                table_value[j,i] = max(table_value[j-1,i],table_value[j-1,index]+V[j])
    return table_value[-1][-1]
```

##### 4.3 空间优化(将二维数组优化为一维数值)

上题可以优化为使用一个数组进行运算。

```python
def packages_optimizer(capacity,N,W,V):
    
    table_value = [0]*(capacity+1)
    for i in range(N):
        for j in range(capacity,-1,-1):
            if j < W[i] : break
            table_value[j] = max(table_value[j],table_value[j-W[i]]+V[i])

    return table_value[capacity]
```

