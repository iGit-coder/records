##### 问题详解

- 问题阐述

  `任意给一个非负整数，找到大于等于该数并是2的幂次的数`

- 代码示例

  ```java
  public int tableSizeFor(cap){
      int n = cap - 1;
      n |= n>>>1;
      n |= n>>>2;
      n |= n>>>4;
      n |= n>>>8;
      n |= n>>>16;
      return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
  }
  ```

- 解释

  由Java的int类型，任何int类型的数使用二进制都可以表示为：

  ```java
  //例如 18
  0000,0000/0000,0000/0000,0000/0001,0010
  ```

  **重要**：从二进制角度分析，其实2的幂次数有个特点就是其最高位为1，其余各位是0，依据这样的特点，那么符合18这个数的解就是

  ```java
  0000,0000/0000,0000/0000,0000/0010,0000//即比18二进制表示的最高位高一位
  ```

  如何完成上述转换呢？

  代码示例的思路是：

  1. 从18对应的最高位开始，依次将低位变为1，如下

  ```java
  n = cap - 1 = 17 //cap=18
  n        -> 0000,0000/0000,0000/0000,0000/0001,0001    //1
  n>>>1    -> 0000,0000/0000,0000/0000,0000/0000,1000    //2  式1和2进行或运算得3
  n|=n>>>1 -> 0000,0000/0000,0000/0000,0000/0001,1000    //3  此时n的值
  //依程序进行
  n|=n>>>2 -> 0000,0000/0000,0000/0000,0000/0001,1110
  n|=n>>>4 -> 0000,0000/0000,0000/0000,0000/0001,1111 
  n|=n>>>8 -> 0000,0000/0000,0000/0000,0000/0001,1111 
  n|=n>>>16-> 0000,0000/0000,0000/0000,0000/0001,1111
  //通过一系列的右移再或运算，最终：从18对应的最高位开始，依次将低位变为了1
  ```

  2. 然后n+1就成为解

  ```java
  n  = 0000,0000/0000,0000/0000,0000/0001,1111
  n+1= 0000,0000/0000,0000/0000,0000/0010,0000
  ```

- 细节分析

  1. 为什么`cap-1`

     > 这是针对给定的数本身就是2的幂次数的情况，比如给定数为4，那么按照上面的流程应该是这样的：
     >
     > 4的二进制表示为 0000,0000/0000,0000/0000,0000/0000,0100
     >
     > 按照上面的思想，从最高位到最低位都变为1，然后在加1最终会得到：
     >
     > 0000,0000/0000,0000/0000,0000/0000,1000  //8
     >
     > 而答案应该为4才对，因为题目是这样的：`找到大于等于该数并是2的幂次的数`
     >
     > 这个时候如果进行`cap-1`,那么情况是这样的：
     >
     > n = 4-1 ->  0000,0000/0000,0000/0000,0000/0000,0011
     >
     > 进行一系列的移动，最终成为了0000,0000/0000,0000/0000,0000/0000,0100 // 4
     >
     > 最终答案就是4了
     >
     > 可以验证减一操作对其他数值同样适用，不影响其他数值的运算结果

     - 课下思考：

       为什么需要移动这么多次，有什么说法？

       





















